create or replace type body Attr_Obj is

  constructor function Attr_Obj return self as RESULT IS
  BEGIN
      count_  := 0;
      names_  := NULL;
      values_ := NULL;
      hash_cache_id_ := NULL;
      RETURN;
  END;

  MEMBER FUNCTION This RETURN Attr_Obj IS
  BEGIN
     RETURN SELF;
  END;

  MEMBER FUNCTION  This_Anydata RETURN ANYDATA IS
  BEGIN
     RETURN ANYDATA.ConvertObject( SELF );
  END;

  MEMBER PROCEDURE Clear IS
  BEGIN
      IF names_ IS NOT NULL THEN
          FOR i_ IN 1..count_ LOOP
              names_ (i_) := NULL;
              values_(i_) := NULL;
          END LOOP;
      END IF;
      count_     := 0;
  END;

  MEMBER FUNCTION  IsEmpty     RETURN BOOLEAN IS
  BEGIN
      RETURN names_ IS NULL OR names_.count = 0;
  END;

  MEMBER FUNCTION Idx( name_ IN VARCHAR2 ) RETURN PLS_INTEGER IS
     i_          PLS_INTEGER;
     name_upper_ VARCHAR2(256);
  BEGIN
     IF name_ IS NOT NULL THEN
         IF hash_cache_id_ IS NULL THEN
             name_upper_ := upper(name_);         
             FOR i_ IN 1..count_ LOOP
                 IF names_(i_) = name_upper_ THEN
                     RETURN i_;
                 END IF;
             END LOOP;
         ELSE
             RETURN Attr_Api.Idx_Cache( hash_cache_id_, upper(name_) );
         END IF;         
     END IF;

     RETURN NULL;
  END;


  MEMBER PROCEDURE Extend_ ( num_ IN PLS_INTEGER DEFAULT 15 ) IS
  BEGIN
      IF names_ IS NULL THEN
          names_          := string_tab();
          values_         := any_tab();
          count_          := 0;
      END IF;
      IF count_ + num_ > names_.count THEN
          names_.Extend ( count_ + num_ - names_.count );
          values_.Extend( count_ + num_ - values_.count );
      END IF;
  END;

  MEMBER FUNCTION  Names    ( idx_ IN PLS_INTEGER ) RETURN VARCHAR2 IS
  BEGIN
      RETURN names_(idx_);
  END;


  MEMBER PROCEDURE Del( idx_  IN PLS_INTEGER) IS
  BEGIN
     IF idx_ IS NOT NULL THEN
         names_(idx_) := NULL;
     END IF;
  END;

  MEMBER PROCEDURE Del( name_ IN VARCHAR2) IS
  BEGIN
     Del( Idx( name_ ) );
  END;

  MEMBER PROCEDURE Add_( name_ IN VARCHAR2, value_ IN VARCHAR2) IS
  BEGIN
     Extend_( 1 );
     count_ := count_ + 1;
     names_(count_)  := upper(name_);
     values_(count_) := ANYDATA.ConvertVarchar2(value_);
  END;

  MEMBER PROCEDURE Add_( name_ IN VARCHAR2, value_ IN NUMBER) IS
  BEGIN
     Extend_( 1 );
     count_ := count_ + 1;
     names_(count_)  := upper(name_);
     values_(count_) := ANYDATA.ConvertNumber(value_);
  END;

  MEMBER PROCEDURE Add_( name_ IN VARCHAR2, value_ IN DATE) IS
  BEGIN
     Extend_( 1 );
     count_ := count_ + 1;
     names_(count_)  := upper(name_);
     values_(count_) := ANYDATA.ConvertDate(value_);
  END;

  MEMBER PROCEDURE Add_( name_ IN VARCHAR2, value_ IN OUT NOCOPY CLOB) IS
  BEGIN
     Extend_( 1 );
     count_ := count_ + 1;
     names_(count_)  := upper(name_);
     values_(count_) := ANYDATA.ConvertCLob(value_);
  END;

  MEMBER PROCEDURE Add_( name_ IN VARCHAR2, value_ IN OUT NOCOPY BLOB) IS
  BEGIN
     Extend_( 1 );
     count_ := count_ + 1;
     names_(count_)  := upper(name_);
     values_(count_) := ANYDATA.ConvertBLob(value_);
  END;

  MEMBER PROCEDURE Add_( name_ IN VARCHAR2, value_ IN OUT NOCOPY Attr_Obj) IS
  BEGIN
     Extend_( 1 );
     count_ := count_ + 1;
     names_(count_)  := upper(name_);
     values_(count_) := ANYDATA.ConvertObject(value_);
  END;

  MEMBER PROCEDURE Add_( name_ IN VARCHAR2, value_ IN OUT NOCOPY ANYDATA ) IS
  BEGIN
     Extend_( 1 );
     count_ := count_ + 1;
     names_(count_)  := upper(name_);
     values_(count_) := value_;
  END;


  MEMBER PROCEDURE Set_( name_ IN VARCHAR2, value_ IN VARCHAR2) IS
     idx_ PLS_INTEGER;
  BEGIN
     idx_ := Idx( name_ );
     IF idx_ IS NULL THEN
         Add_(name_, value_ );
     ELSE
         values_(idx_) := ANYDATA.ConvertVarchar2(value_);
     END IF;
  END;

  MEMBER PROCEDURE Set_( name_ IN VARCHAR2, value_ IN NUMBER) IS
     idx_ PLS_INTEGER;
  BEGIN
     idx_ := Idx( name_ );
     IF idx_ IS NULL THEN
         Add_(name_, value_ );
     ELSE
         values_(idx_) := ANYDATA.ConvertNumber(value_);
     END IF;
  END;

  MEMBER PROCEDURE Set_( name_ IN VARCHAR2, value_ IN DATE) IS
     idx_ PLS_INTEGER;
  BEGIN
     idx_ := Idx( name_ );
     IF idx_ IS NULL THEN
         Add_(name_, value_ );
     ELSE
         values_(idx_) := ANYDATA.ConvertDate(value_);
     END IF;
  END;

  MEMBER PROCEDURE Set_( name_ IN VARCHAR2, value_ IN OUT NOCOPY CLOB) IS
     idx_ PLS_INTEGER;
  BEGIN
     idx_ := Idx( name_ );
     IF idx_ IS NULL THEN
         Add_(name_, value_ );
     ELSE
         values_(idx_) := ANYDATA.ConvertCLob(value_);
     END IF;
  END;

  MEMBER PROCEDURE Set_( name_ IN VARCHAR2, value_ IN OUT NOCOPY BLOB) IS
     idx_ PLS_INTEGER;
  BEGIN
     idx_ := Idx( name_ );
     IF idx_ IS NULL THEN
         Add_(name_, value_ );
     ELSE
         values_(idx_) := ANYDATA.ConvertBLob(value_);
     END IF;
  END;

  MEMBER PROCEDURE Set_( name_ IN VARCHAR2, value_ IN OUT NOCOPY Attr_Obj) IS
     idx_ PLS_INTEGER;
  BEGIN
     idx_ := Idx( name_ );
     IF idx_ IS NULL THEN
         Add_(name_, value_ );
     ELSE
         values_(idx_) := ANYDATA.ConvertObject(value_);
     END IF;
  END;

  MEMBER PROCEDURE Set_( name_ IN VARCHAR2, value_ IN OUT NOCOPY ANYDATA ) IS
     idx_ PLS_INTEGER;
  BEGIN
     idx_ := Idx( name_ );
     IF idx_ IS NULL THEN
         Add_(name_, value_ );
     ELSE
         values_(idx_) := value_;
     END IF;
  END;

  MEMBER FUNCTION Get    ( idx_ IN PLS_INTEGER) RETURN VARCHAR2 IS
     type_  VARCHAR2(128);
  BEGIN
     IF (idx_ IS NOT NULL) AND (idx_ <= count_) THEN
         IF values_(idx_) IS NULL THEN
             RETURN NULL;
         END IF;
         type_ := values_(idx_).GetTypeName();
         IF type_ = 'SYS.VARCHAR2' THEN
             RETURN values_(idx_).AccessVarchar2();
         ELSIF type_ = 'SYS.NUMBER' THEN
             RETURN values_(idx_).AccessNumber();
         ELSIF type_ = 'SYS.DATE' THEN
             RETURN to_char(values_(idx_).AccessDate(), 'YYYY-MM-DD HH24.MI.SS' );
         ELSIF type_ = 'SYS.CLOB' THEN
             RETURN substr(values_(idx_).AccessCLob(),1,32600);
         ELSE
             RETURN 'TYPE: '||type_;
         END IF;
     END IF;
     RETURN NULL;
  END;

  MEMBER FUNCTION Get    ( name_ IN VARCHAR2) RETURN VARCHAR2 IS
     i_     PLS_INTEGER;
  BEGIN
     i_ := instr(name_, '/', -1);
     IF i_ > 0 THEN
         RETURN Get_Record( substr( name_, 1, i_-1 ) ).Get( substr( name_, i_+1 ) );
     END IF;
     RETURN Get( Idx( name_ ) );
  END;

  MEMBER FUNCTION GetN   (idx_ IN PLS_INTEGER) RETURN NUMBER IS
  BEGIN
     IF idx_ IS NOT NULL THEN
         IF  values_(idx_).GetTypeName() = 'SYS.NUMBER' THEN
             RETURN values_(idx_).AccessNumber();
         END IF;
     END IF;
     RETURN NULL;
  END;

  MEMBER FUNCTION GetN   ( name_ IN VARCHAR2) RETURN NUMBER IS
     i_     PLS_INTEGER;
  BEGIN
     i_ := instr(name_, '/', -1);
     IF i_ > 0 THEN
         RETURN Get_Record( substr( name_, 1, i_-1 ) ).GetN( substr( name_, i_+1 ) );
     END IF;
     RETURN GetN( Idx( name_ ) );
  END;

  MEMBER FUNCTION GetD   ( idx_ IN PLS_INTEGER) RETURN DATE IS -- DATE
  BEGIN
     IF idx_ IS NOT NULL THEN
         IF  values_(idx_).GetTypeName() = 'SYS.DATE' THEN
             RETURN Trunc(values_(idx_).AccessDate());
         END IF;
     END IF;
     RETURN NULL;
  END;

  MEMBER FUNCTION GetD   ( name_ IN VARCHAR2) RETURN DATE IS -- DATE
     i_     PLS_INTEGER;
  BEGIN
     i_ := instr(name_, '/', -1);
     IF i_ > 0 THEN
         RETURN Get_Record( substr( name_, 1, i_-1 ) ).GetD( substr( name_, i_+1 ) );
     END IF;
     RETURN GetD( Idx( name_ ) );
  END;

  MEMBER FUNCTION GetT   ( idx_ IN PLS_INTEGER) RETURN DATE IS -- TIME
  BEGIN
     IF idx_ IS NOT NULL THEN
         IF  values_(idx_).GetTypeName() = 'SYS.DATE' THEN
             RETURN values_(idx_).AccessDate();
         END IF;
     END IF;
     RETURN NULL;
  END;


  MEMBER FUNCTION GetT   ( name_ IN VARCHAR2) RETURN DATE IS -- TIME
     i_     PLS_INTEGER;
  BEGIN
     i_ := instr(name_, '/', -1);
     IF i_ > 0 THEN
         RETURN Get_Record( substr( name_, 1, i_-1 ) ).GetT( substr( name_, i_+1 ) );
     END IF;
     RETURN GetT( Idx( name_ ) );
  END;

  MEMBER FUNCTION GetCLob( idx_ IN PLS_INTEGER) RETURN CLOB IS
  BEGIN
     IF idx_ IS NOT NULL THEN
         IF  values_(idx_).GetTypeName() = 'SYS.CLOB' THEN
             RETURN values_(idx_).AccessCLOB();
         END IF;
     END IF;
     RETURN NULL;
  END;

  MEMBER FUNCTION GetCLob( name_ IN VARCHAR2) RETURN CLOB IS
     i_     PLS_INTEGER;
  BEGIN
     i_ := instr(name_, '/', -1);
     IF i_ > 0 THEN
         RETURN Get_Record( substr( name_, 1, i_-1 ) ).GetClob( substr( name_, i_+1 ) );
     END IF;
     RETURN GetCLob( Idx( name_ ) );
  END;

  MEMBER FUNCTION GetBLob ( idx_ IN PLS_INTEGER) RETURN BLOB IS
  BEGIN
     IF idx_ IS NOT NULL THEN
         IF  values_(idx_).GetTypeName() = 'SYS.BLOB' THEN
             RETURN values_(idx_).AccessBLOB();
         END IF;
     END IF;
     RETURN NULL;
  END;

  MEMBER FUNCTION GetBLob ( name_ IN VARCHAR2) RETURN BLOB IS
     i_     PLS_INTEGER;
  BEGIN
     i_ := instr(name_, '/', -1);
     IF i_ > 0 THEN
         RETURN Get_Record( substr( name_, 1, i_-1 ) ).GetBLob( substr( name_, i_+1 ) );
     END IF;
     RETURN GetBLob( Idx( name_ ) );
  END;

  MEMBER FUNCTION Get_Record ( idx_ IN PLS_INTEGER  ) RETURN Attr_Obj IS
     tmp_  PLS_INTEGER;
     obj_  Attr_Obj;
  BEGIN
     IF idx_ IS NOT NULL THEN
        IF values_(idx_).GetTypeName() LIKE '%ATTR_OBJ' THEN
             tmp_ := values_(idx_).GetObject( obj_ );
             RETURN obj_;
        END IF;
     END IF;
     RETURN NULL;
  END;

  MEMBER FUNCTION Get_Record ( name_ IN VARCHAR2 ) RETURN Attr_Obj IS
     i_    PLS_INTEGER;
     tmp_  PLS_INTEGER;
     obj_  Attr_Obj;
     idx_  PLS_INTEGER;
  BEGIN
     IF name_ IS NULL THEN
         RETURN SELF;
     END IF;

     i_ := instr(name_, '/', -1);
     IF i_ > 0 THEN
         DECLARE
             list_   FND_Api.List;
             obj2_   Attr_Obj;
         BEGIN
             list_ := FND_Api.Split( name_, '/' );
             idx_ := Idx( list_(1) );
             IF idx_ IS NULL THEN
                 DBMS_output.put_line( 'Record Not Found1 :'||list_(1) );
                 IF FND_Api.Log_Is_On() THEN
                     Error_Api.Error( 'ATTR_OBJ', 'Record Not Found1 :'||name_ );
                 END IF;
             END IF;
             tmp_ := values_( Idx( list_(1) ) ).GetObject( obj_ );
             FOR i_ IN 2..list_.count LOOP
                 idx_ := obj_.Idx( list_(i_) );
                 IF idx_ IS NULL THEN
                     DBMS_output.put_line( 'Record Not Found2 :'||list_(1) );
                     IF FND_Api.Log_Is_On() THEN
                         Error_Api.Error( 'ATTR_OBJ', 'Record Not Found2 :'||list_(1) );
                     END IF;
                 END IF;
                 tmp_ := obj_.values_( idx_ ).GetObject( obj2_ );
                 obj_ := obj2_;
                 obj2_ := NULL;
             END LOOP;
             RETURN obj_;
         END;
     END IF;
     idx_ := Idx( name_ );
     IF idx_ IS NOT NULL THEN
        IF values_(idx_).GetTypeName() LIKE '%ATTR_OBJ' THEN
             tmp_ := values_(idx_).GetObject( obj_ );
             RETURN obj_;
        END IF;
     ELSE
         DBMS_output.put_line( 'Record Not Found3 :'||name_ );
         IF FND_Api.Log_Is_On() THEN
             Error_Api.Error( 'ATTR_OBJ', 'Record Not Found3 :'||name_ );
         END IF;
     END IF;
     RETURN NULL;
  END;

  MEMBER FUNCTION Get_Anydata( idx_ IN PLS_INTEGER) RETURN ANYDATA IS
  BEGIN
     IF idx_ IS NOT NULL THEN
         RETURN values_(idx_);
     END IF;
     RETURN NULL;
  END;


  MEMBER FUNCTION Get_Anydata( name_ IN VARCHAR2) RETURN ANYDATA IS
     i_     PLS_INTEGER;
  BEGIN
     i_ := instr(name_, '/', -1);
     IF i_ > 0 THEN
         RETURN Get_Record( substr( name_, 1, i_-1 ) ).Get_Anydata( substr( name_, i_+1 ) );
     END IF;
     i_ := Idx( name_ );
     IF i_ IS NOT NULL THEN
         RETURN values_(i_);
     ELSE
         DBMS_output.put_line( 'Record Not Found4 :'||name_ );
         IF FND_Api.Log_Is_On() THEN
             Error_Api.Error( 'ATTR_OBJ', 'Record Not Found4 :'||name_ );
         END IF;
     END IF;
     RETURN NULL;
  END;


  MEMBER FUNCTION Get_Type   ( name_ IN VARCHAR2) RETURN VARCHAR2 IS
     i_     PLS_INTEGER;
  BEGIN
     i_ := instr(name_, '/', -1);
     IF i_ > 0 THEN
         RETURN Get_Record( substr( name_, 1, i_-1 ) ).Get_Type( substr( name_, i_+1 ) );
     END IF;
     i_ := Idx( name_ );
     IF i_ IS NOT NULL THEN
         RETURN Get_Type( i_ );
     END IF;
     RETURN NULL;
  END;

  MEMBER FUNCTION Get_Type   ( idx_ IN PLS_INTEGER) RETURN VARCHAR2 IS
     type_   VARCHAR2(40);
  BEGIN
     IF values_(idx_) IS NULL THEN
         RETURN 'VARCHAR2';
     END IF;
     type_ := values_(idx_).GetTypeName();
     IF type_ LIKE '%ATTR_TAB' THEN
         RETURN 'TABLE';
     ELSIF type_ LIKE '%ATTR_OBJ' THEN
         RETURN 'RECORD';
     END IF;
     RETURN replace(type_, 'SYS.', '' );
  END;

  MEMBER PROCEDURE From_XML( xml_ IN OUT NOCOPY XMLType, path_ IN VARCHAR2 := '' ) IS
     clob_  CLOB;
  BEGIN
     clob_ := xml_.getClobVal();
     From_XML( clob_, path_ );
  END;

  MEMBER PROCEDURE From_XML( xml_ IN OUT NOCOPY CLOB, path_ IN VARCHAR2 := '', with_attr_ IN BOOLEAN DEFAULT FALSE ) IS
   parser_              DBMS_Xmlparser.Parser;
   document_            DBMS_Xmldom.Domdocument;
   element_             DBMS_Xmldom.Domelement;

   child_name_          VARCHAR2(200);
   element_name_        VARCHAR2(200);
   upper_path_          VARCHAR2(500);

   PROCEDURE ChildLoop( element_ IN DBMS_Xmldom.DOMNode, obj_ IN OUT NOCOPY Attr_Obj, curr_path_ IN VARCHAR2 ) IS
       child_nodes_    DBMS_Xmldom.Domnodelist;
       child_attr_     DBMS_Xmldom.DomNamedNodeMap;
       child_node_     DBMS_Xmldom.Domnode;
       child_len_      PLS_INTEGER;
       attr_len_       PLS_INTEGER;
       i_              PLS_INTEGER;
       node_attr_obj_  Attr_Obj;
   BEGIN
      child_nodes_ := DBMS_Xmldom.GetChildNodes(element_);
      IF with_attr_ THEN
          child_attr_  := DBMS_Xmldom.GetAttributes(element_);
          attr_len_    := DBMS_Xmldom.GetLength(child_attr_);
      ELSE
          attr_len_    := 0;
      END IF;
      IF attr_len_ > 0 THEN
         node_attr_obj_    := Attr_Obj();
         i_ := 0;
         LOOP
            child_node_ := DBMS_Xmldom.Item(child_attr_, i_);
            node_attr_obj_.Add_( DBMS_Xmldom.GetNodeName( child_node_ ), DBMS_Xmldom.GetNodeValue(child_node_) );
            i_ := i_ + 1;
            EXIT WHEN i_ >= attr_len_;
         END LOOP;
      END IF;
      child_len_   := DBMS_Xmldom.GetLength(child_nodes_);
      IF child_len_ = 0 THEN
          IF curr_path_ LIKE upper_path_ THEN
              obj_.Add_( DBMS_Xmldom.GetNodeName( element_ ), '' );
              IF attr_len_ > 0 THEN
                  obj_.Add_( DBMS_Xmldom.GetNodeName( element_ )||'_ATTR', node_attr_obj_ );
              END IF;
          END IF;
      ELSE
          i_ := 0;
          child_node_ := DBMS_Xmldom.Item(child_nodes_, i_);
          child_name_ := DBMS_Xmldom.GetNodeName(child_node_);
          IF child_name_ = '#text' THEN
              IF curr_path_ LIKE upper_path_ THEN
                  IF attr_len_ > 0 THEN
                      obj_.Add_( DBMS_Xmldom.GetNodeName( element_ )||'_ATTR', node_attr_obj_ );
                  END IF;
                  obj_.Add_( DBMS_Xmldom.GetNodeName( element_ ), DBMS_Xmldom.GetNodeValue(child_node_) );
              END IF;
          ELSIF child_name_ = 'item' THEN
              DECLARE
                  child_nodes2_    DBMS_Xmldom.Domnodelist;
                  attr_tab_        Attr_Api.Attr_Tab_;
                  tab_name_        VARCHAR2(256);
                  attr_obj_        Attr_Obj;
                  child_len2_      PLS_INTEGER;
                  insert_          BOOLEAN;
                  init_            BOOLEAN;
              BEGIN
                  tab_name_ := DBMS_Xmldom.GetNodeName( element_ );
                  insert_ := curr_path_||tab_name_||'/' LIKE upper_path_;
                  init_   := FALSE;
                  IF insert_ THEN
                      attr_tab_ := Attr_Api.Attr_Tab_();
                      attr_tab_.Extend(child_len_);
                      FOR j_ IN 1..child_len_ LOOP
                          attr_tab_(j_) := Attr_Obj();
                      END LOOP;
                      init_ := TRUE;
                  END IF;
                  LOOP
                      i_ := i_ + 1;
                      child_nodes2_ := DBMS_Xmldom.GetChildNodes(child_node_);
                      child_len2_ := DBMS_Xmldom.GetLength(child_nodes2_);
                      FOR j_ IN 0..child_len2_-1 LOOP
                          IF insert_ THEN
                             ChildLoop( DBMS_Xmldom.Item(child_nodes2_, j_), attr_tab_( i_ ), curr_path_||tab_name_||'/ITEM/' );
                          ELSE
                             attr_obj_ := Attr_Obj();
                             ChildLoop( DBMS_Xmldom.Item(child_nodes2_, j_), attr_obj_, curr_path_||tab_name_||'/ITEM/' );
                          END IF;
                      END LOOP;

                      IF insert_ THEN
                          NULL;
                      ELSIF attr_obj_.count_ > 0 THEN
                          IF NOT init_ THEN
                              attr_tab_ := Attr_Api.Attr_Tab_(attr_obj_);
                              init_ := TRUE;
                          ELSE
                              attr_tab_.Extend();
                              attr_tab_( attr_tab_.count ) := attr_obj_;
                          END IF;
                      END IF;

                      EXIT WHEN i_ >= child_len_;
                      child_node_ := DBMS_Xmldom.Item(child_nodes_, i_);
                  END LOOP;
                  IF init_ THEN
                      IF attr_len_ > 0 THEN
                          obj_.Add_( tab_name_||'_ATTR', node_attr_obj_ );
                      END IF;
                      Attr_Api.Add_Attr_Table( obj_, tab_name_, attr_tab_ );
                  END IF;
              END;
          ELSE
              DECLARE
                  attr_obj_      Attr_Obj;
                  element_name_  VARCHAR2(200);
                  new_obj_       BOOLEAN;
              BEGIN
                  element_name_ := upper(DBMS_Xmldom.GetNodeName( element_ ));
                  new_obj_ := curr_path_ LIKE upper_path_;
                  IF new_obj_ THEN
                      attr_obj_ := Attr_Obj();
                  END IF;
                  LOOP
                      IF new_obj_ THEN
                          ChildLoop( child_node_, attr_obj_, curr_path_||element_name_||'/' );
                      ELSE
                          ChildLoop( child_node_, obj_, curr_path_||element_name_||'/' );
                      END IF;

                      i_ := i_ + 1;
                      EXIT WHEN i_ >= child_len_;
                      child_node_ := DBMS_Xmldom.Item(child_nodes_, i_);
                  END LOOP;
                  IF new_obj_ THEN
                      IF attr_len_ > 0 THEN
                          obj_.Add_( element_name_||'_ATTR', node_attr_obj_ );
                      END IF;
                      obj_.Add_( element_name_, attr_obj_ );
                  END IF;
              END;
          END IF;
      END IF;
   END;

  BEGIN
   --FND_API.Time_Start( 'Attr_Obj.From_XML' );
   IF path_ IS NULL THEN
       upper_path_ := '/%';
   ELSE
       upper_path_ := upper(path_);
       IF substr(upper_path_, length(upper_path_)) = '%' THEN
           NULL;
       ELSIF substr(upper_path_, length(upper_path_)) = '/' THEN
           upper_path_ := upper_path_||'%';
       ELSE
           upper_path_ := upper_path_||'/%';
       END IF;
   END IF;
   --FND_APi.Log( xml_ );
   -- Create XML Parser.
   parser_ := DBMS_XmlParser.NewParser;
   DBMS_Xmlparser.Setvalidationmode(parser_, False);
   -- Parse XML into DOM object
   DBMS_Xmlparser.ParseClob(parser_, xml_);
   -- Document
   document_ := DBMS_Xmlparser.GetDocument(parser_);
   -- Root element
   element_ := DBMS_Xmldom.GetDocumentElement(document_);
   Clear();
   ChildLoop( DBMS_Xmldom.MakeNode(element_), SELF, '/' );
   DBMS_xmldom.freedocument(document_);
   DBMS_xmlparser.freeparser(parser_);
   --FND_API.Time_Stop( 'Attr_Obj.From_XML' );
  END;



  MEMBER FUNCTION Get_Struct (path_ IN VARCHAR2 DEFAULT '%', print_full_path_ IN VARCHAR2 DEFAULT 'N') RETURN two_string_tab IS
     upper_path_  VARCHAR2(500);
     desc_        two_string_tab;
     nr_          PLS_INTEGER;
     type_        VARCHAR2(30);

     PROCEDURE Attr_Desc_( obj_ IN Attr_Obj, full_path_ IN VARCHAR2, space_path_ IN VARCHAR2) IS
     BEGIN
         FOR i_ IN 1..obj_.count_ LOOP
             type_ := obj_.Get_Type( i_ );
             IF full_path_||obj_.names_(i_) LIKE upper_path_ THEN
                 desc_.Extend();
                 nr_ := nr_ + 1;
                 IF print_full_path_ = 'Y' THEN
                     desc_( nr_ ) := two_string_rec( full_path_||obj_.names_(i_), type_ );
                 ELSE
                     desc_( nr_ ) := two_string_rec( space_path_||obj_.names_(i_), type_ );
                 END IF;
             END IF;

             IF type_ = 'RECORD' THEN
                 Attr_Desc_( obj_.Get_Record( obj_.names_(i_) ), full_path_||obj_.names_(i_)||'/', space_path_||'     ');
             ELSIF type_ = 'TABLE' THEN
                 DECLARE
                     tab_  Attr_Api.Attr_Tab_;
                 BEGIN
                     tab_ := Attr_API.Get_Attr_Table_( obj_, obj_.names_(i_));
                     IF tab_.count > 0 THEN
                         Attr_Desc_( tab_(1), full_path_||obj_.names_(i_)||'/', space_path_||'     ');
                     END IF;
                 END;
             END IF;
         END LOOP;
     END;
  BEGIN
     upper_path_ := upper(path_);
     IF upper_path_ IS NULL THEN
         upper_path_ := '%';
     ELSIF substr(upper_path_, length(upper_path_) ) != '%' THEN
         upper_path_ := upper_path_ || '%';
     END IF;

     desc_ := two_string_tab();
     nr_   := 0;
     Attr_Desc_( SELF, '/', '' );

     RETURN desc_;
  END;

  MEMBER FUNCTION Get_Values (path_ IN VARCHAR2 DEFAULT '%', print_full_path_ IN VARCHAR2 DEFAULT 'N' )    RETURN two_string_tab IS
     upper_path_  VARCHAR2(500);
     values_      two_string_tab;
     nr_          PLS_INTEGER;
     type_        VARCHAR2(30);

     PROCEDURE Attr_Values_( obj_ IN Attr_Obj, full_path_ IN VARCHAR2, space_path_ IN VARCHAR2) IS
         extend_       BOOLEAN;
         value_        VARCHAR2(4000);
     BEGIN
         extend_ := full_path_ LIKE upper_path_;
         IF extend_ THEN
              values_.Extend(obj_.count_);
         END IF;
         FOR i_ IN 1..obj_.count_ LOOP
             type_ := obj_.Get_Type( i_ );
             IF full_path_||obj_.names_(i_) LIKE upper_path_ THEN
                 IF NOT extend_ THEN
                     values_.Extend();
                 END IF;
                 nr_ := nr_ + 1;
                 value_ := substr(obj_.Get( i_ ), 1, 4000);
                 IF value_ LIKE 'TYPE: %.ATTR_OBJ' THEN
                     value_ := '';
                 END IF;
                 IF print_full_path_ = 'Y' THEN
                     values_( nr_ ) := two_string_rec( full_path_||obj_.names_(i_),  value_ );
                 ELSE
                     values_( nr_ ) := two_string_rec( space_path_||obj_.names_(i_), value_ );
                 END IF;
             END IF;

             IF type_ = 'RECORD' THEN
                 Attr_Values_( obj_.Get_Record( i_ ), full_path_||obj_.names_(i_)||'/', space_path_||'     ');
             ELSIF type_ = 'TABLE' THEN
                 DECLARE
                     tab_    Attr_Api.Attr_Tab_;
                     print_  BOOLEAN;
                 BEGIN
                     print_ := full_path_||obj_.names_(i_)||'/' LIKE upper_path_;
                     tab_ := Attr_API.Get_Attr_Table_( obj_, obj_.names_(i_));
                     IF print_ THEN
                         values_.Extend( tab_.count-1 );
                     END IF;
                     FOR j_ IN 1.. tab_.count-1 LOOP
                         Attr_Values_( tab_(j_), full_path_||obj_.names_(i_)||'/', space_path_||'     ');
                         IF print_ THEN
                             nr_ := nr_ + 1;
                             IF print_full_path_ = 'Y' THEN
                                 values_( nr_ ) := two_string_rec( full_path_||obj_.names_(i_)||'/item',  '' );
                             ELSE
                                 values_( nr_ ) := two_string_rec( space_path_||obj_.names_(i_)||'/item', '' );
                             END IF;
                         END IF;
                     END LOOP;
                     IF tab_.count > 0 THEN
                         Attr_Values_( tab_(tab_.count), full_path_||obj_.names_(i_)||'/', space_path_||'     ');
                     END IF;
                 END;
             END IF;
         END LOOP;
     END;
  BEGIN
     upper_path_ := upper(path_);
     IF upper_path_ IS NULL THEN
         upper_path_ := '%';
     ELSIF substr(upper_path_, length(upper_path_) ) != '%' THEN
         upper_path_ := upper_path_ || '%';
     END IF;

     values_ := two_string_tab();
     nr_   := 0;
     Attr_Values_( SELF, '/', '' );

     RETURN values_;
  END;

  MEMBER PROCEDURE Log( prefix_ IN STRING DEFAULT '' ) IS
      type_  VARCHAR2(50);
  BEGIN
      FND_Api.Log( prefix_||'**** ATTR_OBJ ****' );
      FOR i_ IN 1..count_ LOOP
          type_ := Get_Type(i_);
          IF type_ = 'RECORD'  THEN
              FND_Api.Log( prefix_||'     '||names_(i_)||'=><<RECORD>>' );
              DECLARE
                  obj_   Attr_Obj;
              BEGIN
              obj_ := Get_Record( i_ );
              obj_.Log( prefix_||'      '); 
              END;
          ELSIF type_ = 'TABLE'  THEN
              FND_Api.Log( prefix_||'     '||names_(i_)||'=><<TABLE>>' );
              DECLARE
                  tab_    Attr_Api.Attr_Tab_;
              BEGIN
                  tab_ := Attr_API.Get_Attr_Table_( SELF, names_(i_));
                  FOR j_ IN 1..tab_.count LOOP
                     FND_Api.Log( prefix_||'     '||names_(i_)||'=><<ITEM '||j_||'>>' );
                     tab_(j_).Log(prefix_||'      '); 
                  END LOOP;
              END;
              FND_Api.Log( prefix_||'     '||names_(i_)||'=><<TABLE END>>' );
          ELSE
              FND_Api.Log( prefix_||'     '||names_(i_)||'=>'||type_||'=>'||Get(i_) );
          END IF;
      END LOOP;
      FND_Api.Log( prefix_||'******************' );
  END;

  MEMBER PROCEDURE Log_Error( error_id_ IN NUMBER, prefix_ IN STRING DEFAULT '' ) IS
      type_  VARCHAR2(50);
  BEGIN
      Error_Api.Log( error_id_, prefix_||'**** ATTR_OBJ ****' );
      FOR i_ IN 1..count_ LOOP
          type_ := Get_Type(i_);
          IF type_ = 'RECORD'  THEN
              Error_Api.Log( error_id_, prefix_||'     '||names_(i_)||'=><<RECORD>>' );
              DECLARE
                  obj_   Attr_Obj;
              BEGIN
              obj_ := Get_Record( i_ );
              obj_.Log_Error( error_id_, prefix_||'      '); 
              END;
          ELSIF type_ = 'TABLE'  THEN
              Error_Api.Log( error_id_, prefix_||'     '||names_(i_)||'=><<TABLE>>' );
              DECLARE
                  tab_    Attr_Api.Attr_Tab_;
              BEGIN
                  tab_ := Attr_API.Get_Attr_Table_( SELF, names_(i_));
                  FOR j_ IN 1..tab_.count LOOP
                     Error_Api.Log( error_id_, prefix_||'     '||names_(i_)||'=><<ITEM '||j_||'>>' );
                     tab_(j_).Log_Error( error_id_, prefix_||'      '); 
                  END LOOP;
              END;
              Error_Api.Log( error_id_, prefix_||'     '||names_(i_)||'=><<TABLE END>>' );
          ELSE
              Error_Api.Log( error_id_, prefix_||'     '||names_(i_)||'=>'||type_||'=>'||Get(i_) );
          END IF;
      END LOOP;
      Error_Api.Log( error_id_, prefix_||'******************' );
  END;

  MEMBER FUNCTION To_JSON RETURN CLOB IS
      json_       CLOB;
      ret_        CLOB;
      tab_        Attr_Api.Attr_Tab_;
      type_       VARCHAR2(20);
      delim_      VARCHAR2(20);
  BEGIN
      DBMS_lob.createtemporary( json_, true );
      DBMS_lob.append( json_, '{' );
      FOR i_ IN 1..count_ LOOP
          IF names_(i_) IS NOT NULL THEN
              type_ := Get_Type( i_ );
              IF type_ = 'RECORD' THEN
                  DBMS_lob.append( json_, delim_ || lower(names_(i_)) || ': ' || Get_Record( names_(i_) ).To_JSON() );
              ELSIF type_ = 'TABLE' THEN
                  tab_ := Attr_Api.Get_Attr_Table_( SELF, names_(i_) );
                  DBMS_lob.append( json_, delim_ || lower(names_(i_)) || ': [' );
                  FOR j_ IN 1..tab_.count LOOP
                      IF j_ > 1 THEN
                          DBMS_lob.append( json_, ','||chr(13)||chr(10) );
                      END IF;
                      DBMS_lob.append( json_, tab_(j_).To_JSON() );
                  END LOOP;
                  DBMS_lob.append( json_, ']' );
              ELSE
                  DBMS_lob.append( json_, delim_ || lower(names_(i_)) || ': ''' || Get(names_(i_)) || ''' ' );
              END IF;
              IF delim_ IS NULL THEN
                  delim_ := ','||chr(13)||chr(10);
              END IF;
          END IF;
      END LOOP;
      DBMS_lob.append( json_, '}' );
      ret_ := json_;
      DBMS_LOB.freetemporary(json_);
      RETURN ret_;
  END;

  MEMBER PROCEDURE Copy_From( attr_ IN Attr_Obj ) IS
  BEGIN
      IF attr_ IS NULL THEN
          Clear();
      ELSE
          count_ := attr_.count_;
          names_ := attr_.names_;
          values_ := attr_.values_;
      END IF;
  END;
  
  /*
  MEMBER PROCEDURE Copy_From( attr_ IN AttrS_Obj ) IS
  BEGIN
      Clear();
      IF attr_ IS NOT NULL THEN
          FOR i_ IN 1.. attr_.count_ LOOP
               Add_( attr_.names_(i_), attr_.values_(i_) );
          END LOOP;
      END IF;
  END;
  */
  
  MEMBER FUNCTION  Equal( attr_ IN Attr_Obj ) RETURN BOOLEAN IS
      type_  VARCHAR2(30);
  BEGIN
      IF attr_ IS NULL THEN
          RETURN count_ = 0;
      END IF;
      IF count_ <> attr_.count_ THEN
          FND_API.Log( 'Count', count_, attr_.count_ );
          RETURN FALSE;
      END IF;
      FOR i_ IN 1.. attr_.count_ LOOP
          IF nvl(names_(i_),'_') <> nvl(attr_.names_(i_),'_') THEN
              FND_API.Log( 'name('||i_||')', nvl(names_(i_),'_'), nvl(attr_.names_(i_),'_') );
              RETURN FALSE;
          END IF;
          type_ := Get_Type(i_);
          IF type_ <> attr_.Get_Type(i_) THEN
              FND_API.Log( 'Type('||i_||')', type_, attr_.Get_Type(i_) );
              RETURN FALSE;
          END IF;
          IF type_ = 'RECORD' THEN
              DECLARE
                  rec1_  Attr_Obj;
                  rec2_  Attr_Obj;
              BEGIN
                  rec1_ := Get_Record( i_ );
                  rec2_ := attr_.Get_Record( i_ );
                  IF NOT rec1_.Equal( rec2_ ) THEN
                      RETURN FALSE;
                  END IF; 
              END;
          ELSIF type_ = 'TABLE' THEN
              DECLARE
                  tab1_     Attr_Api.Attr_Tab_;
                  tab2_     Attr_Api.Attr_Tab_;
              BEGIN
                  tab1_ := Attr_Api.Get_Attr_Table_( SELF, names_(i_) );
                  tab2_ := Attr_Api.Get_Attr_Table_( attr_, names_(i_) );
                  IF tab1_.count <> tab2_.count THEN
                      FND_API.Log( 'Tab Count', tab1_.count, tab2_.count );
                      RETURN FALSE;
                  END IF;
                  FOR j_ IN 1..tab1_.count LOOP
                      IF tab1_(j_) IS NULL AND tab2_(j_) IS NULL THEN
                          NULL;
                      ELSIF tab1_(j_) IS NOT NULL THEN
                          IF NOT tab1_(j_).Equal( tab2_(j_) ) THEN
                              RETURN FALSE;
                          END IF;
                      ELSE                          
                          IF NOT tab2_(j_).Equal( tab1_(j_) ) THEN
                              RETURN FALSE;
                          END IF;
                      END IF;
                  END LOOP;
              END;
          ELSIF Get(i_) <> attr_.Get(i_) THEN
              FND_API.Log( 'Value('||i_||')', Get(i_), attr_.Get(i_) );
              RETURN FALSE;
          END IF;
      END LOOP;
      RETURN TRUE;
  END;

  MEMBER PROCEDURE Save_To_Session  ( session_id_ IN NUMBER, attr_name_ IN VARCHAR2 ) IS
      PRAGMA AUTONOMOUS_TRANSACTION;
      row_no_    NUMBER;
      
      PROCEDURE Save_( attr_ IN Attr_Obj, path_ IN VARCHAR2 ) IS
          type_   VARCHAR2(30);
          value_  VARCHAR2(32767);
      BEGIN
          FOR i_ IN 1..attr_.count_ LOOP
              type_ := attr_.Get_Type(i_);
              IF type_ = 'VARCHAR2' THEN
                  value_ := attr_.Get(i_);
                  IF nvl(length(value_),0) <= 2000 THEN
                      INSERT INTO FND_SESSION_DATA_TAB
                          (SESSION_ID, DATA_TYPE, ROW_NO, S01, S02, s03, s04)
                      VALUES
                          (session_id_, attr_name_, row_no_, path_, attr_.names_(i_), 'STRING', value_);
                      row_no_ := row_no_ + 1;
                  ELSE
                      INSERT INTO FND_SESSION_DATA_TAB
                          (SESSION_ID, DATA_TYPE, ROW_NO, S01, S02, s03, s04)
                      VALUES
                          (session_id_, attr_name_, row_no_, path_, attr_.names_(i_), 'CLOB', row_no_);
                      INSERT INTO FND_SESSION_DATA_CLOB_TAB
                          (SESSION_ID, DATA_TYPE, ROW_NO, clob_data)
                      VALUES
                          (session_id_, attr_name_, row_no_, value_);
                      row_no_ := row_no_ + 1;
                  END IF;
              ELSIF type_ IN ('NUMBER','DATE','BOOLEAN') THEN
                  INSERT INTO FND_SESSION_DATA_TAB
                      (SESSION_ID, DATA_TYPE, ROW_NO, S01, S02, s03, s04)
                  VALUES
                      (session_id_, attr_name_, row_no_, path_, attr_.names_(i_), type_, attr_.Get(i_));
                  row_no_ := row_no_ + 1;
              ELSIF type_ = 'CLOB' THEN
                  INSERT INTO FND_SESSION_DATA_TAB
                      (SESSION_ID, DATA_TYPE, ROW_NO, S01, S02, s03, s04)
                  VALUES
                      (session_id_, attr_name_, row_no_, path_, attr_.names_(i_), 'CLOB', row_no_);
                  INSERT INTO FND_SESSION_DATA_CLOB_TAB
                      (SESSION_ID, DATA_TYPE, ROW_NO, clob_data)
                  VALUES
                      (session_id_, attr_name_, row_no_, attr_.GetClob(i_));
                  row_no_ := row_no_ + 1;
              ELSIF type_ = 'BLOB' THEN
                  INSERT INTO FND_SESSION_DATA_TAB
                      (SESSION_ID, DATA_TYPE, ROW_NO, S01, S02, s03, s04)
                  VALUES
                      (session_id_, attr_name_, row_no_, path_, attr_.names_(i_), 'BLOB', row_no_);
                  INSERT INTO FND_SESSION_DATA_BLOB_TAB
                      (SESSION_ID, DATA_TYPE, ROW_NO, blob_data)
                  VALUES
                      (session_id_, attr_name_, row_no_, attr_.GetBlob(i_));
                  row_no_ := row_no_ + 1;
              ELSIF type_ = 'RECORD' THEN
                  DECLARE
                      rec_ Attr_Obj;
                  BEGIN
                      rec_ := attr_.Get_Record( i_ );
                      INSERT INTO FND_SESSION_DATA_TAB
                          (SESSION_ID, DATA_TYPE, ROW_NO, S01, S02, s03, s04)
                      VALUES
                          (session_id_, attr_name_, row_no_, path_, attr_.names_(i_), type_, '1');
                      row_no_ := row_no_ + 1;
                      Save_( rec_, path_||'#'||attr_.names_(i_) );
                  END;
              ELSIF type_ = 'TABLE' THEN
                  DECLARE
                      tab_     Attr_Api.Attr_Tab_;
                      count_   NUMBER;
                  BEGIN
                      tab_ := Attr_Api.Get_Attr_Table_( attr_, attr_.names_(i_) );
                      count_ := tab_.count;
                      INSERT INTO FND_SESSION_DATA_TAB
                          (SESSION_ID, DATA_TYPE, ROW_NO, S01, S02, s03, s04)
                      VALUES
                          (session_id_, attr_name_, row_no_, path_, attr_.names_(i_), type_, count_);
                      row_no_ := row_no_ + 1;
                      FOR j_ IN 1..count_ LOOP
                          Save_( tab_(j_), path_||'#'||attr_.names_(i_)||'#'||j_ );
                      END LOOP;
                  END;
              END IF;
          END LOOP;
      END;
  BEGIN
      row_no_ := 1;
      Save_( SELF, '_' );
      COMMIT;
  END;

  MEMBER PROCEDURE Read_From_Session( session_id_ IN NUMBER, attr_name_ IN VARCHAR2 ) IS

         TYPE Stack_Rec IS RECORD (
            name_   VARCHAR2(50),
            path_   VARCHAR2(2000),
            type_   VARCHAR2(20),
            num_    PLS_INTEGER,
            len_    PLS_INTEGER,
            attr_   Attr_Obj );
         TYPE Stack_Tab        IS TABLE OF Stack_Rec INDEX BY PLS_INTEGER;
         TYPE Stack_Table_Tab  IS TABLE OF Attr_Tab  INDEX BY PLS_INTEGER;
         
         stack_len_       PLS_INTEGER;
         stack_           Stack_Tab;
         stack_tab_len_   PLS_INTEGER;
         stack_tab_       Stack_Table_Tab;
         
         PROCEDURE Stack_Pop IS
         BEGIN
             IF stack_(stack_len_).type_ = 'TABLE' THEN
                 stack_tab_(stack_tab_len_)( stack_(stack_len_).num_ ) := stack_(stack_len_).attr_;
                 
                 IF stack_(stack_len_).num_ = stack_(stack_len_).len_ THEN
                     Attr_Api.Set_Attr_Table( stack_(stack_len_-1).attr_, stack_(stack_len_).name_, stack_tab_(stack_tab_len_) );
                     stack_tab_(stack_tab_len_) := NULL;
                     stack_tab_len_ := stack_tab_len_ - 1;
                 END IF;
                 
                 stack_(stack_len_).attr_ := NULL;
                 stack_len_ := stack_len_ - 1;
             ELSE --type_ = RECORD
                 stack_(stack_len_-1).attr_.Add_( stack_(stack_len_).name_, stack_(stack_len_).attr_ );
                 stack_(stack_len_).attr_ := NULL;
                 stack_len_ := stack_len_ - 1;
             END IF;
         END;
         
         PROCEDURE Stack_Push( type_ IN VARCHAR2, name_ IN VARCHAR2, path_ IN VARCHAR2, num_ IN PLS_INTEGER, len_ IN PLS_INTEGER) IS
             
         BEGIN
             stack_len_ := stack_len_ + 1;
             stack_(stack_len_).attr_ := Attr_Obj();
             stack_(stack_len_).type_ := type_;
             stack_(stack_len_).name_ := name_;
             stack_(stack_len_).path_ := path_;
             stack_(stack_len_).num_  := num_;             
             stack_(stack_len_).len_  := len_;
             NULL;
         END;

         PROCEDURE Line_( row_no_ IN number, path_ IN VARCHAR2, name_ IN VARCHAR2, type_ IN VARCHAR2, value_ IN VARCHAR2 ) IS
         BEGIN
             
             WHILE stack_(stack_len_).path_ != path_ LOOP
                 Stack_Pop();
             END LOOP;
             
             IF type_ = 'STRING' OR type_ = 'BOOLEAN' THEN
                 stack_(stack_len_).attr_.Add_( name_, value_ );
             ELSIF type_ = 'NUMBER' THEN
                 stack_(stack_len_).attr_.Add_( name_, to_number(value_) );
             ELSIF type_ = 'DATE' THEN
                 stack_(stack_len_).attr_.Add_( name_, to_date(value_, 'YYYY-MM-DD HH24.MI.SS') );
             ELSIF type_ = 'CLOB' THEN
                 DECLARE
                     clob_ CLOB;
                 BEGIN
                     SELECT clob_data
                       INTO clob_
                       FROM FND_SESSION_DATA_CLOB_TAB
                      WHERE session_id = session_id_
                        AND data_type = attr_name_
                        AND row_no = row_no_;
                     stack_(stack_len_).attr_.Add_( name_, clob_ );
                 END;
             ELSIF type_ = 'BLOB' THEN
                 DECLARE
                     blob_ BLOB;
                 BEGIN
                     SELECT blob_data
                       INTO blob_
                       FROM FND_SESSION_DATA_BLOB_TAB
                      WHERE session_id = session_id_
                        AND data_type = attr_name_
                        AND row_no = row_no_;
                     stack_(stack_len_).attr_.Add_( name_, blob_ );
                 END;
             ELSIF type_ = 'RECORD' THEN
                 Stack_Push( type_, name_, path_||'#'||name_, 1, 1 );
             ELSIF type_ = 'TABLE' THEN
                 IF to_number(value_) > 0 THEN
                     stack_tab_len_ := stack_tab_len_ + 1;
                     stack_tab_(stack_tab_len_) := Attr_Tab();
                     stack_tab_(stack_tab_len_).Extend( to_number(value_) );
                     FOR i IN REVERSE 1..to_number(value_) LOOP
                         Stack_Push( type_, name_, path_||'#'||name_||'#'||i, i, to_number(value_) );                     
                     END LOOP;
                 ELSE
                     DECLARE
                         tab_   Attr_Tab;
                     BEGIN
                         tab_ := Attr_Tab();
                         Attr_Api.Set_Attr_Table( stack_(stack_len_).attr_, name_, tab_ );
                     END;
                 END IF;  
             END IF;
         END;
  BEGIN
      Clear();
      stack_(1).attr_  := Attr_Obj();
      stack_(1).path_  := '_';
      stack_len_       := 1;
      stack_tab_len_   := 0;

      FOR r_ IN (SELECT row_no, S01, S02, s03, s04
                   FROM FND_SESSION_DATA_TAB
                  WHERE session_id = session_id_
                    AND data_type = attr_name_
                  ORDER BY row_no ) LOOP
          Line_( r_.row_no, r_.s01, r_.s02, r_.s03, r_.s04 );
      END LOOP;
      WHILE stack_len_ > 1 LOOP
           Stack_Pop();
      END LOOP;
      Copy_From( stack_(1).attr_ );
  END;
  
  MEMBER PROCEDURE Save_To_File  ( dir_ IN VARCHAR2, file_name_ IN VARCHAR2 ) IS
      file_            UTL_FILE.FILE_TYPE;
      file_num_        PLS_INTEGER;
      file_base_name_  VARCHAR2(100);

      PROCEDURE Save_( attr_ IN Attr_Obj, path_ IN VARCHAR2 ) IS
          type_   VARCHAR2(30);
          value_  VARCHAR2(32767);
      BEGIN
          FOR i_ IN 1..attr_.count_ LOOP
              type_ := attr_.Get_Type(i_);
              IF type_ = 'VARCHAR2' THEN
                  value_ := attr_.Get(i_);
                  IF nvl(length(value_),0) <= 30000 THEN
                      UTL_FILE.PUT_LINE( file_, path_||'!'||attr_.names_(i_)||'!STRING!'||replace(value_, chr(13)||chr(10), chr(38)||'NewLine;' ) );
                  ELSE
                      file_num_ := file_num_ + 1;
                      UTL_FILE.PUT_LINE( file_, path_||'!'||attr_.names_(i_)||'!CLOB!'||file_num_);
                      FND_API.Write_File( dir_, file_base_name_||'p'||file_num_||'.txt', value_);
                  END IF;
              ELSIF type_ IN ('NUMBER','DATE','BOOLEAN') THEN
                  UTL_FILE.PUT_LINE( file_, path_||'!'||attr_.names_(i_)||'!'||type_||'!'||attr_.Get(i_));
              ELSIF type_ = 'CLOB' THEN
                  file_num_ := file_num_ + 1;
                  UTL_FILE.PUT_LINE( file_, path_||'!'||attr_.names_(i_)||'!CLOB!'||file_num_);
                  FND_API.Write_File( dir_, file_base_name_||'p'||file_num_||'.txt', attr_.GetCLob(i_) );
              ELSIF type_ = 'BLOB' THEN
                  file_num_ := file_num_ + 1;
                  UTL_FILE.PUT_LINE( file_, path_||'!'||attr_.names_(i_)||'!BLOB!'||file_num_);
                  FND_API.Write_File( dir_, file_base_name_||'p'||file_num_||'.txt', attr_.GetBLob(i_));
              ELSIF type_ = 'RECORD' THEN
                  DECLARE
                      rec_ Attr_Obj;
                  BEGIN
                      rec_ := attr_.Get_Record( i_ );
                      UTL_FILE.PUT_LINE( file_, path_||'!'||attr_.names_(i_)||'!RECORD!1');
                      Save_( rec_, path_||'#'||attr_.names_(i_) );
                  END;
              ELSIF type_ = 'TABLE' THEN
                  DECLARE
                      tab_     Attr_Api.Attr_Tab_;
                      count_   NUMBER;
                  BEGIN
                      tab_ := Attr_Api.Get_Attr_Table_( attr_, attr_.names_(i_) );
                      count_ := tab_.count;
                      UTL_FILE.PUT_LINE( file_, path_||'!'||attr_.names_(i_)||'!TABLE!'||count_);
                      FOR j_ IN 1..count_ LOOP
                          Save_( tab_(j_), path_||'#'||attr_.names_(i_)||'#'||j_ );
                      END LOOP;
                  END;
              END IF;
          END LOOP;
      END;
  BEGIN
      file_num_ := 0;
      file_base_name_ := substr( file_name_, 1, instr(file_name_, '.', -1, 1 )-1 )||'_';
      file_ := UTL_FILE.FOPEN( dir_, file_name_, 'W');
      BEGIN
      Save_( SELF, '_' );
      EXCEPTION WHEN OTHERS THEN
          utl_file.fclose( file_ );
          RAISE;
      END;
      utl_file.fclose( file_ );
      FND_Api.Write_File( dir_, file_base_name_||'send.txt', '' );
  END;
  
  MEMBER PROCEDURE Read_From_File( dir_ IN VARCHAR2, file_name_ IN VARCHAR2, delete_file_ IN VARCHAR2 DEFAULT 'Y' ) IS

         file_            UTL_FILE.FILE_TYPE;
         row_             VARCHAR2(32767);
         file_num_        PLS_INTEGER;
         file_base_name_  VARCHAR2(100);
         
         i_               PLS_INTEGER;
         j_               PLS_INTEGER;
         k_               PLS_INTEGER;
         
         TYPE Stack_Rec IS RECORD (
            name_   VARCHAR2(50),
            path_   VARCHAR2(2000),
            type_   VARCHAR2(20),
            num_    PLS_INTEGER,
            len_    PLS_INTEGER,
            attr_   Attr_Obj );
         TYPE Stack_Tab        IS TABLE OF Stack_Rec INDEX BY PLS_INTEGER;
         TYPE Stack_Table_Tab  IS TABLE OF Attr_Tab  INDEX BY PLS_INTEGER;
         
         stack_len_       PLS_INTEGER;
         stack_           Stack_Tab;
         stack_tab_len_   PLS_INTEGER;
         stack_tab_       Stack_Table_Tab;
         
         PROCEDURE Stack_Pop IS
         BEGIN
             IF stack_(stack_len_).type_ = 'TABLE' THEN
                 stack_tab_(stack_tab_len_)( stack_(stack_len_).num_ ) := stack_(stack_len_).attr_;
                 
                 IF stack_(stack_len_).num_ = stack_(stack_len_).len_ THEN
                     Attr_Api.Set_Attr_Table( stack_(stack_len_-1).attr_, stack_(stack_len_).name_, stack_tab_(stack_tab_len_) );
                     stack_tab_(stack_tab_len_) := NULL;
                     stack_tab_len_ := stack_tab_len_ - 1;
                 END IF;
                 
                 stack_(stack_len_).attr_ := NULL;
                 stack_len_ := stack_len_ - 1;
             ELSE --type_ = RECORD
                 stack_(stack_len_-1).attr_.Add_( stack_(stack_len_).name_, stack_(stack_len_).attr_ );
                 stack_(stack_len_).attr_ := NULL;
                 stack_len_ := stack_len_ - 1;
             END IF;
         END;
         
         PROCEDURE Stack_Push( type_ IN VARCHAR2, name_ IN VARCHAR2, path_ IN VARCHAR2, num_ IN PLS_INTEGER, len_ IN PLS_INTEGER) IS
             
         BEGIN
             stack_len_ := stack_len_ + 1;
             stack_(stack_len_).attr_ := Attr_Obj();
             stack_(stack_len_).type_ := type_;
             stack_(stack_len_).name_ := name_;
             stack_(stack_len_).path_ := path_;
             stack_(stack_len_).num_  := num_;             
             stack_(stack_len_).len_  := len_;
             NULL;
         END;

         PROCEDURE Line_( path_ IN VARCHAR2, name_ IN VARCHAR2, type_ IN VARCHAR2, value_ IN VARCHAR2 ) IS
         BEGIN
             
             WHILE stack_(stack_len_).path_ != path_ LOOP
                 Stack_Pop();
             END LOOP;
             
             IF type_ = 'STRING' OR type_ = 'BOOLEAN' THEN
                 stack_(stack_len_).attr_.Add_( name_, Replace( value_, chr(38)||'NewLine;', chr(13)||chr(10)) );
             ELSIF type_ = 'NUMBER' THEN
                 stack_(stack_len_).attr_.Add_( name_, to_number(value_) );
             ELSIF type_ = 'DATE' THEN
                 stack_(stack_len_).attr_.Add_( name_, to_date(value_, 'YYYY-MM-DD HH24.MI.SS') );
             ELSIF type_ = 'CLOB' THEN
                 DECLARE
                     clob_ CLOB;
                 BEGIN
                     file_num_ := file_num_ + 1;
                     clob_ := FND_API.Read_CFile( dir_, file_base_name_||'p'||file_num_||'.txt');
                     stack_(stack_len_).attr_.Add_( name_, clob_ );
                 END;
             ELSIF type_ = 'BLOB' THEN
                 DECLARE
                     blob_ BLOB;
                 BEGIN
                     file_num_ := file_num_ + 1;
                     blob_ := FND_API.Read_BFile( dir_, file_base_name_||'p'||file_num_||'.txt');
                     stack_(stack_len_).attr_.Add_( name_, blob_ );
                 END;
             ELSIF type_ = 'RECORD' THEN
                 Stack_Push( type_, name_, path_||'#'||name_, 1, 1 );
             ELSIF type_ = 'TABLE' THEN
                 IF to_number(value_) > 0 THEN
                     stack_tab_len_ := stack_tab_len_ + 1;
                     stack_tab_(stack_tab_len_) := Attr_Tab();
                     stack_tab_(stack_tab_len_).Extend( to_number(value_) );
                     FOR i IN REVERSE 1..to_number(value_) LOOP
                         Stack_Push( type_, name_, path_||'#'||name_||'#'||i, i, to_number(value_) );                     
                     END LOOP;
                 ELSE
                     DECLARE
                         tab_   Attr_Tab;
                     BEGIN
                         tab_ := Attr_Tab();
                         Attr_Api.Set_Attr_Table( stack_(stack_len_).attr_, name_, tab_ );
                     END;
                 END IF;  
             END IF;
         END;
  BEGIN
      file_num_ := 0;
      file_base_name_ := substr( file_name_, 1, instr(file_name_, '.', -1, 1 )-1 )||'_';
      Clear();
      stack_(1).attr_  := Attr_Obj();
      stack_(1).path_  := '_';
      stack_len_       := 1;
      stack_tab_len_   := 0;

      file_ := UTL_FILE.FOPEN( dir_, file_name_, 'R');
      IF UTL_FILE.IS_OPEN(file_) THEN
          BEGIN
          LOOP
            BEGIN
              UTL_FILE.GET_LINE(file_, row_ );
              i_ := instr( row_, '!' );
              j_ := instr( row_, '!', i_+1 );
              k_ := instr( row_, '!', j_+1 );           
              Line_( substr(row_, 1, i_-1), substr(row_, i_+1, j_-i_-1), substr(row_, j_+1, k_-j_-1), substr(row_, k_+1) );
            EXCEPTION WHEN NO_DATA_FOUND THEN
              EXIT;   
            END;
          END LOOP;
          EXCEPTION WHEN OTHERS THEN
              utl_file.fclose( file_ );
              RAISE;
          END;
          utl_file.fclose( file_ );
      END IF;
      WHILE stack_len_ > 1 LOOP
           Stack_Pop();
      END LOOP;
      Copy_From( stack_(1).attr_ );
      IF delete_file_ = 'Y' THEN
          FND_Api.Delete_File( dir_, file_name_ );
          FOR i_ IN 1..file_num_ LOOP
              FND_Api.Delete_File( dir_, file_base_name_||'p'||i_||'.txt');
          END LOOP;
          FND_Api.Delete_File( dir_, file_base_name_||'receive.txt');
      END IF;
  END;
  


END;
/
