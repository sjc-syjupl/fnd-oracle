create or replace type body AttrS_Obj is

  constructor function AttrS_Obj return self as RESULT IS
  BEGIN
      count_  := 0;
      names_  := NULL;
      values_ := NULL;
      hash_cache_id_ := NULL;
      RETURN;
  END;

  MEMBER FUNCTION This RETURN AttrS_Obj IS
  BEGIN
     RETURN SELF;
  END;

  MEMBER PROCEDURE Clear IS
  BEGIN
      IF names_ IS NOT NULL THEN
          FOR i_ IN 1..count_ LOOP
              names_ (i_) := NULL;
              values_(i_) := NULL;
          END LOOP;
      END IF;
      count_     := 0;
  END;

  MEMBER FUNCTION  IsEmpty     RETURN BOOLEAN IS
  BEGIN
      RETURN names_ IS NULL OR names_.count = 0;
  END;

  MEMBER FUNCTION Idx( name_ IN VARCHAR2 ) RETURN PLS_INTEGER IS
     i_          PLS_INTEGER;
     name_upper_ VARCHAR2(50);
  BEGIN
     IF name_ IS NOT NULL THEN
         IF hash_cache_id_ IS NULL THEN
             name_upper_ := upper(name_);         
             FOR i_ IN 1..count_ LOOP
                 IF names_(i_) = name_upper_ THEN
                     RETURN i_;
                 END IF;
             END LOOP;
         ELSE
             RETURN Attr_Api.Idx_Cache( hash_cache_id_, upper(name_) );
         END IF;         
     END IF;

     RETURN NULL;
  END;


  MEMBER PROCEDURE Extend_ ( num_ IN PLS_INTEGER DEFAULT 15 ) IS
  BEGIN
      IF names_ IS NULL THEN
          names_          := name_tab();
          values_         := string_tab();
          count_          := 0;
      END IF;
      IF count_ + num_ > names_.count THEN
          names_.Extend ( count_ + num_ - names_.count );
          values_.Extend( count_ + num_ - values_.count );
      END IF;
  END;

  MEMBER FUNCTION  Names    ( idx_ IN PLS_INTEGER ) RETURN VARCHAR2 IS
  BEGIN
      RETURN names_(idx_);
  END;


  MEMBER PROCEDURE Del( idx_  IN PLS_INTEGER) IS
  BEGIN
     IF idx_ IS NOT NULL THEN
         names_(idx_) := NULL;
     END IF;
  END;

  MEMBER PROCEDURE Del( name_ IN VARCHAR2) IS
  BEGIN
     Del( Idx( name_ ) );
  END;

  MEMBER PROCEDURE Add_( name_ IN VARCHAR2, value_ IN VARCHAR2) IS
  BEGIN
     Extend_( 1 );
     count_ := count_ + 1;
     names_(count_)  := upper(name_);
     values_(count_) := value_;
  END;


  MEMBER PROCEDURE Set_( name_ IN VARCHAR2, value_ IN VARCHAR2) IS
     idx_ PLS_INTEGER;
  BEGIN
     idx_ := Idx( name_ );
     IF idx_ IS NULL THEN
         Add_(name_, value_ );
     ELSE
         values_(idx_) := value_;
     END IF;
  END;


  MEMBER FUNCTION Get    ( idx_ IN PLS_INTEGER) RETURN VARCHAR2 IS
  BEGIN
     IF (idx_ IS NOT NULL) AND (idx_ <= count_) THEN
         RETURN values_(idx_);
     END IF;
     RETURN NULL;
  END;

  MEMBER FUNCTION Get    ( name_ IN VARCHAR2) RETURN VARCHAR2 IS
  BEGIN
     IF hash_cache_id_ IS NULL THEN
         RETURN Get( Idx( name_ ) );
     ELSE
         RETURN values_( Attr_Api.Idx_Cache( hash_cache_id_, upper(name_) ) );
     END IF;
  END;

  MEMBER PROCEDURE Copy_From( attr_ IN Attr_Obj ) IS
  BEGIN
      IF attr_ IS NULL THEN
          Clear();
      ELSE
          names_ := name_TAB();
          names_.Extend( attr_.names_.count );
          FOR i IN 1..attr_.names_.count LOOP
              names_(i)          := attr_.names_(i);
          END LOOP;
          count_          := attr_.count_;
          values_         := string_tab();
          values_.Extend( count_ );
          FOR i IN 1..count_ LOOP
              values_(i)  := attr_.values_(i).AccessVarchar2();
          END LOOP;
      END IF;
  END;

  MEMBER PROCEDURE Copy_From( attr_ IN AttrS_Obj ) IS
  BEGIN
      IF attr_ IS NULL THEN
          Clear();
      ELSE
          count_ := attr_.count_;
          names_ := attr_.names_;
          values_ := attr_.values_;
      END IF;
  END;

  MEMBER FUNCTION  Equal( attr_ IN AttrS_Obj ) RETURN BOOLEAN IS
  BEGIN
      IF attr_ IS NULL THEN
          RETURN count_ = 0;
      END IF;
      IF count_ <> attr_.count_ THEN
          RETURN FALSE;
      END IF;
      FOR i_ IN 1.. attr_.count_ LOOP
          IF nvl(names_(i_),'_') <> nvl(attr_.names_(i_),'_') THEN
              RETURN FALSE;
          END IF;
          IF nvl(values_(i_),'_') <> nvl(attr_.values_(i_),'_') THEN
              RETURN FALSE;
          END IF;
      END LOOP;      
      RETURN TRUE;
  END;

  MEMBER PROCEDURE Save_To_Session  ( session_id_ IN NUMBER, attr_name_ IN VARCHAR2 ) IS
      PRAGMA AUTONOMOUS_TRANSACTION;
  BEGIN
      FOR i_ IN 1..count_ LOOP
          INSERT INTO FND_SESSION_DATA_TAB
              (SESSION_ID, DATA_TYPE, ROW_NO, S01, S02, S03, S04 )
          VALUES
              (session_id_, attr_name_, i_, '_', names_(i_), 'STRING', values_(i_));
      END LOOP;
      COMMIT;
  END;

  MEMBER PROCEDURE Read_From_Session( session_id_ IN NUMBER, attr_name_ IN VARCHAR2 ) IS
  BEGIN
      Clear();
      FOR r_ IN (SELECT s02, s04
                   FROM FND_SESSION_DATA_TAB
                  WHERE session_id = session_id_
                    AND data_type = attr_name_
                  ORDER BY row_no ) LOOP
          Add_( r_.s02, r_.s04 );
      END LOOP;
  END;

  MEMBER PROCEDURE Save_To_File  ( dir_ IN VARCHAR2, file_name_ IN VARCHAR2 ) IS
      file_             UTL_FILE.FILE_TYPE;
      file_base_name_   VARCHAR2(200);
  BEGIN
      file_base_name_ := substr( file_name_, 1, instr(file_name_, '.', -1, 1 )-1 )||'_';
      file_ := UTL_FILE.FOPEN( dir_, file_name_, 'W');
      --IF UTL_FILE.IS_OPEN(file_) THEN
          FOR i_ IN 1..count_ LOOP
              UTL_FILE.PUT_LINE( file_, '_!'||names_(i_)||'!STRING!'||Replace(values_(i_), chr(13)||chr(10), chr(38)||'NewLine;' ) );
          END LOOP;
          utl_file.fclose( file_ );
      --END IF;
      FND_Api.Write_File( dir_, file_base_name_||'send.txt', '' );
  END;
  
  MEMBER PROCEDURE Read_From_File( dir_ IN VARCHAR2, file_name_ IN VARCHAR2, delete_file_ IN VARCHAR2 DEFAULT 'Y' ) IS
      file_   UTL_FILE.FILE_TYPE;
      line_   VARCHAR2(32767);
      i_      PLS_INTEGER;
      j_      PLS_INTEGER;
      k_      PLS_INTEGER;
      file_base_name_   VARCHAR2(200);
  BEGIN
      file_base_name_ := substr( file_name_, 1, instr(file_name_, '.', -1, 1 )-1 )||'_';
      Clear();
      file_ := UTL_FILE.FOPEN( dir_, file_name_, 'R');
      IF UTL_FILE.IS_OPEN(file_) THEN
          BEGIN
          LOOP
            BEGIN
              UTL_FILE.GET_LINE(file_, line_ );
              i_ := instr( line_, '!' );
              j_ := instr( line_, '!', i_+1 );
              k_ := instr( line_, '!', j_+1 );           
              Add_( substr(line_, i_+1, j_-i_-1) , replace(substr(line_, k_+1), chr(38)||'NewLine;', chr(13)||chr(10)) );
            EXCEPTION WHEN NO_DATA_FOUND THEN
              EXIT;   
            END;
          END LOOP;
          EXCEPTION WHEN OTHERS THEN
              utl_file.fclose( file_ );
              RAISE;
          END;
          utl_file.fclose( file_ );
      END IF;
      IF delete_file_ = 'Y' THEN
          FND_Api.Delete_File( dir_, file_name_ );
          FND_Api.Delete_File( dir_, file_base_name_||'receive.txt');
      END IF;
  END;


  MEMBER PROCEDURE Log( prefix_ IN VARCHAR2 DEFAULT NULL ) IS
  BEGIN
      FND_Api.Log( prefix_||'**** ATTRS_OBJ ****' );
      FOR i_ IN 1..count_ LOOP
          FND_Api.Log( prefix_||'     '||names_(i_)||'=>'||values_(i_) );
      END LOOP;
      FND_Api.Log( prefix_||'******************' );
  END;

  MEMBER PROCEDURE Log_Error( error_id_ IN NUMBER, prefix_ IN STRING DEFAULT '' ) IS
  BEGIN
      Error_Api.Log( error_id_, prefix_||'**** ATTRS_OBJ ****' );
      FOR i_ IN 1..count_ LOOP
          Error_Api.Log( error_id_, prefix_||'     '||names_(i_)||'=>'||values_(i_) );
      END LOOP;
      Error_Api.Log( error_id_, prefix_||'******************' );
  END;
    

END;
/
