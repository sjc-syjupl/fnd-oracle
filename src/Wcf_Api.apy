create or replace package body Wcf_Api is

    service_address_  VARCHAR2(200) := 'http://localhost:8081/WcfService/Service.svc';
    token_            VARCHAR2(50)  := '2gNgFxbuZNA4yb6y';
    
    FUNCTION Attr_To_Blob( attr_ IN OUT NOCOPY Attr_Obj) RETURN BLOB IS
      blob_       BLOB;
      ret_        BLOB;
      pos_        PLS_INTEGER;
      
      PROCEDURE Add_Raw( raw_ IN RAW ) IS
          len_   NUMBER;
      BEGIN
          len_ := nvl(utl_raw.length( raw_ ),0);
          DBMS_lob.write( blob_, 10, pos_, utl_raw.cast_to_raw( lpad( len_,10) ) );
          pos_ := pos_ + 10;
          IF len_ > 0 THEN
              DBMS_lob.write( blob_, len_, pos_, raw_ );
              pos_ := pos_ + len_;
          END IF;
      END;
      
      PROCEDURE Obj_To_Blob_( obj_ IN OUT NOCOPY Attr_Obj, path_ IN VARCHAR2 ) IS
          tab_    Attr_Api.Attr_Tab_;
          rec_    Attr_Obj;
          type_   VARCHAR2(30);
          name_   VARCHAR2(200);
      BEGIN 
          IF obj_ IS NULL THEN
              RETURN;
          END IF;
          FOR i_ IN 1..obj_.count_ LOOP
              name_ := obj_.names_(i_);
              IF name_ IS NOT NULL THEN
                  type_ := obj_.Get_Type( i_ );
                  Add_Raw( utl_raw.cast_to_raw( path_||'!'||name_||'!'||type_) );
                  IF type_ IN ('VARCHAR2','DATE','BOOLEAN') THEN
                      Add_Raw( utl_raw.cast_to_raw( obj_.Get(i_)) );
                  ELSIF type_ ='NUMBER' THEN
                      Add_Raw( utl_raw.cast_to_raw( replace(obj_.Get(i_),',','.') ) );
                  ELSIF type_ ='CLOB' THEN
                      DECLARE
                          start_       PLS_INTEGER;
                          len_         PLS_INTEGER;
                          amount_      PLS_INTEGER;
                          tmp_clob_    CLOB;
                      BEGIN
                          tmp_clob_ := obj_.GetClob(i_);
                          len_ := DBMS_lob.getlength( tmp_clob_ );
                          Add_Raw( utl_raw.cast_to_raw( to_char(len_) ) );
                          start_ := 1;
                          WHILE start_ <= len_ LOOP
                              amount_ := least( 10000, len_ - start_ + 1 );
                              Add_Raw( utl_raw.cast_to_raw(DBMS_LOB.SUBSTR( tmp_clob_, amount => amount_, offset => start_ )) );
                              start_ := start_ + 10000;
                          END LOOP;
                      END;
                  ELSIF type_ ='BLOB' THEN
                      DECLARE
                          start_       PLS_INTEGER;
                          len_         PLS_INTEGER;
                          amount_      PLS_INTEGER;
                          tmp_blob_    BLOB;
                      BEGIN
                          tmp_blob_ := obj_.GetBlob(i_);
                          len_ := DBMS_lob.getlength( tmp_blob_ );
                          Add_Raw( utl_raw.cast_to_raw( to_char(len_) ) );
                          start_ := 1;
                          WHILE start_ <= len_ LOOP
                              amount_ := least( 32000, len_ - start_ + 1 );
                              DBMS_lob.write( blob_, amount_, pos_, DBMS_LOB.Substr(tmp_blob_, amount_, start_ ));
                              pos_ := pos_ + amount_;
                              start_ := start_ + 32000;
                          END LOOP;
                      END;
                  ELSIF type_ = 'RECORD' THEN
                      rec_ := obj_.Get_Record(name_);
                      Obj_To_Blob_( rec_, path_||'#'|| name_ );
                  ELSIF type_ = 'TABLE' THEN
                      tab_ := Attr_Api.Get_Attr_Table_( obj_, name_ );
                      Add_Raw( utl_raw.cast_to_raw( to_char(tab_.count) ) );
                      FOR j_ IN 1..tab_.count LOOP
                          Obj_To_Blob_( tab_(j_), path_||'#'|| name_||'#'||j_ );
                      END LOOP;
                  ELSE
                       Error_Api.Error( 'UNKNOWN_TYPE', 'Unknown type :P1', type_ );
                  END IF;            
              END IF;
          END LOOP;
      END;
      
  BEGIN
      pos_ := 1;
      DBMS_lob.createtemporary( blob_, true );
      Obj_To_Blob_( attr_, '_' );
      ret_ := blob_;
      DBMS_LOB.freetemporary(blob_);
      RETURN ret_;
/*
<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns="http://www.bimodal-solutions.com/">
   <soapenv:Header>
      <paramRequestHeader>
         <EnvId>?</EnvId>
         <Param1>?</Param1>
         <Param2>?</Param2>
         <Param3>?</Param3>
         <Param4>?</Param4>
         <Param5>?</Param5>
         <ProcedureName>?</ProcedureName>
         <Token>?</Token>
         <UserId>?</UserId>
      </paramRequestHeader>
   </soapenv:Header>
   <soapenv:Body>
      <ParamRequest>
         <bodyXml>ala i ola</bodyXml>
      </ParamRequest>
   </soapenv:Body>
</soapenv:Envelope>
*/        
    END;

    FUNCTION Blob_To_Attr( blob_ IN OUT NOCOPY BLOB ) RETURN Attr_Obj IS
         start_           PLS_INTEGER;
         pos_             PLS_INTEGER;
         blob_len_        PLS_INTEGER;  
         line_            VARCHAR2(2000);
         i_               PLS_INTEGER;
         j_               PLS_INTEGER;

         TYPE Stack_Rec IS RECORD (
            name_   VARCHAR2(50),
            path_   VARCHAR2(2000),
            type_   VARCHAR2(20),
            num_    PLS_INTEGER,
            len_    PLS_INTEGER,
            attr_   Attr_Obj );
         TYPE Stack_Tab        IS TABLE OF Stack_Rec INDEX BY PLS_INTEGER;
         TYPE Stack_Table_Tab  IS TABLE OF Attr_Tab  INDEX BY PLS_INTEGER;
         
         stack_len_       PLS_INTEGER;
         stack_           Stack_Tab;
         stack_tab_len_   PLS_INTEGER;
         stack_tab_       Stack_Table_Tab;
         
         FUNCTION Read_Line RETURN STRING IS
             len_   NUMBER;
         BEGIN
             len_ := to_number(trim(utl_raw.cast_to_varchar2( DBMS_LOB.Substr(blob_, 10, pos_ ) )));
             pos_ := pos_ + 10 + len_;
             IF len_ > 0 THEN
                 RETURN utl_raw.cast_to_varchar2( DBMS_LOB.Substr(blob_, len_, pos_ - len_ ) );
             ELSE
                 RETURN NULL;
             END IF;
         END;
         
         PROCEDURE Stack_Pop IS
         BEGIN
             IF stack_(stack_len_).type_ = 'TABLE' THEN
                 stack_tab_(stack_tab_len_)( stack_(stack_len_).num_ ) := stack_(stack_len_).attr_;
                 
                 IF stack_(stack_len_).num_ = stack_(stack_len_).len_ THEN
                     Attr_Api.Set_Attr_Table( stack_(stack_len_-1).attr_, stack_(stack_len_).name_, stack_tab_(stack_tab_len_) );
                     stack_tab_(stack_tab_len_) := NULL;
                     stack_tab_len_ := stack_tab_len_ - 1;
                 END IF;
                 
                 stack_(stack_len_).attr_ := NULL;
                 stack_len_ := stack_len_ - 1;
             ELSE --type_ = RECORD
                 stack_(stack_len_-1).attr_.Add_( stack_(stack_len_).name_, stack_(stack_len_).attr_ );
                 stack_(stack_len_).attr_ := NULL;
                 stack_len_ := stack_len_ - 1;
             END IF;
         END;
         
         PROCEDURE Stack_Push( type_ IN VARCHAR2, name_ IN VARCHAR2, path_ IN VARCHAR2, num_ IN PLS_INTEGER, len_ IN PLS_INTEGER) IS
             
         BEGIN
             stack_len_ := stack_len_ + 1;
             stack_(stack_len_).attr_ := Attr_Obj();
             stack_(stack_len_).type_ := type_;
             stack_(stack_len_).name_ := name_;
             stack_(stack_len_).path_ := path_;
             stack_(stack_len_).num_  := num_;             
             stack_(stack_len_).len_  := len_;
             NULL;
         END;

         PROCEDURE Read_Attr( path_ IN VARCHAR2, name_ IN VARCHAR2, type_ IN VARCHAR2 ) IS
             len_   PLS_INTEGER;
         BEGIN
             WHILE stack_(stack_len_).path_ != path_ LOOP
                 Stack_Pop();
             END LOOP;

             IF type_ IN ('VARCHAR2','STRING','BOOLEAN') THEN
                 stack_(stack_len_).attr_.Add_( name_, Read_Line() );
             ELSIF type_ = 'DATE' THEN
                 stack_(stack_len_).attr_.Add_( name_, to_date( Read_Line(), 'yyyy-mm-dd hh24:mi:ss') );
             ELSIF type_ = 'NUMBER' THEN
                 stack_(stack_len_).attr_.Add_( name_, to_number(Read_Line()) );
             ELSIF type_ = 'CLOB' THEN
                 len_ := Read_Line(); 
                 DECLARE 
                     tmp_clob_   CLOB;
                 BEGIN
                     IF len_ > 0 THEN
                         DBMS_lob.createtemporary( tmp_clob_, true );
                         WHILE nvl(DBMS_lob.getlength(tmp_clob_),0) < len_ LOOP
                             DBMS_lob.append( tmp_clob_, Read_Line() );
                         END LOOP;
                         stack_(stack_len_).attr_.Add_( name_, tmp_clob_ );
                         DBMS_lob.freetemporary( tmp_clob_ );
                     ELSE
                         tmp_clob_ := empty_clob();
                         stack_(stack_len_).attr_.Add_( name_, tmp_clob_ );
                     END IF;
                 END;
             ELSIF type_ = 'BLOB' THEN
                 len_ := Read_Line(); 
                 DECLARE 
                     tmp_blob_   BLOB;
                     start_      PLS_INTEGER;
                     amount_     PLS_INTEGER;
                 BEGIN
                     IF len_ > 0 THEN
                         DBMS_lob.createtemporary( tmp_blob_, true );
                         start_ := 1;
                         WHILE start_ <= len_ LOOP
                             amount_ := least( 32000, len_ - start_ + 1);
                             DBMS_lob.write( tmp_blob_, amount_, start_, DBMS_LOB.Substr(blob_, amount_, pos_ ) );
                             start_ := start_ + amount_;
                             pos_ := pos_ + amount_;
                         END LOOP;
                         stack_(stack_len_).attr_.Add_( name_, tmp_blob_ );
                         DBMS_lob.freetemporary( tmp_blob_ );
                     ELSE
                         tmp_blob_ := empty_blob();
                         stack_(stack_len_).attr_.Add_( name_, tmp_blob_ );
                     END IF;
                 END;
             ELSIF type_ = 'RECORD' THEN
                 Stack_Push( type_, name_, path_||'#'||name_, 1, 1 );
             ELSIF type_ = 'TABLE' THEN
                 len_ := Read_Line(); 
                 IF len_ > 0 THEN
                     stack_tab_len_ := stack_tab_len_ + 1;
                     stack_tab_(stack_tab_len_) := Attr_Tab();
                     stack_tab_(stack_tab_len_).Extend( len_ );
                     FOR i IN REVERSE 1..len_ LOOP
                         Stack_Push( type_, name_, path_||'#'||name_||'#'||i, i, len_ );
                     END LOOP;
                 ELSE
                     DECLARE
                         tab_   Attr_Tab;
                     BEGIN
                         tab_ := Attr_Tab();
                         Attr_Api.Set_Attr_Table( stack_(stack_len_).attr_, name_, tab_ );
                     END;
                 END IF;  
             END IF;
         END;
         
    BEGIN
          stack_(1).attr_  := Attr_Obj();
          stack_(1).path_  := '_';
          stack_len_       := 1;
          stack_tab_len_   := 0;
          
          pos_ := 1;
          blob_len_ := DBMS_lob.getlength( blob_ );
          WHILE pos_ <= blob_len_ LOOP
              line_ := Read_Line();
              i_ := instr( line_, '!' );
              j_ := instr( line_, '!', i_+1 );
              Read_Attr( substr(line_, 1, i_-1), substr(line_, i_+1, j_-i_-1), substr(line_, j_+1) );
          END LOOP;
          
          WHILE stack_len_ > 1 LOOP
               Stack_Pop();
          END LOOP;
          RETURN stack_(1).attr_;
/*
<s:Envelope xmlns:s="http://schemas.xmlsoap.org/soap/envelope/">
   <s:Body>
      <ExecProcResponse xmlns="http://www.bimodal-solutions.com/">
         <ExecProcResult xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
            <AttrList>
               <AttrXML>
                  <Name>TEST</Name>
                  <Path/>
                  <Type>STRING</Type>
                  <Value>Hello word.</Value>
               </AttrXML>
            </AttrList>
         </ExecProcResult>
      </ExecProcResponse>
   </s:Body>
</s:Envelope>*/        
    END;
    
    FUNCTION To_Base64( blob_ IN OUT NOCOPY BLOB ) RETURN BLOB IS
        tmp_blob_    BLOB;
        ret_         BLOB;
        pos_         PLS_INTEGER;
        start_       PLS_INTEGER;
        amount_      PLS_INTEGER;
        len_         PLS_INTEGER;
        buffer_len_  PLS_INTEGER;
        buffer_      RAW(32000);
    BEGIN
        len_ := DBMS_LOB.GETLENGTH( blob_ );
        IF blob_ IS NULL OR nvl(len_,0) = 0 THEN
            RETURN NULL;
        END IF;
        IF len_ <= 24000 THEN
            RETURN utl_encode.base64_encode( blob_ );
        END IF;
        pos_ := 1;
        DBMS_lob.createtemporary( tmp_blob_, true );
        start_ := 1;
        WHILE start_ <= len_ LOOP
            amount_ := least( 21000, len_ - start_ + 1 );  -- 21000 must be divided by 3
            buffer_ := utl_encode.base64_encode( DBMS_LOB.SUBSTR( blob_, amount => amount_, offset => start_ ) );
            buffer_len_ := utl_raw.length( buffer_ );
            DBMS_lob.write( tmp_blob_, buffer_len_, pos_, buffer_ );
            pos_ := pos_ + amount_;
        END LOOP;        
        ret_ := tmp_blob_;
        DBMS_LOB.freetemporary(tmp_blob_);
        RETURN ret_;
    END;
    
    FUNCTION From_Base64(  blob_ IN OUT NOCOPY BLOB, start_pos_ IN NUMBER DEFAULT 1, stop_pos_ IN NUMBER DEFAULT NULL ) RETURN BLOB IS
        tmp_blob_     BLOB;
        ret_          BLOB;
        pos_          PLS_INTEGER;
        start_        PLS_INTEGER;
        amount_       PLS_INTEGER;
        len_          PLS_INTEGER;
        buffer_len_   PLS_INTEGER;
        buffer_       VARCHAR2(32000);
        prev_buffer_  VARCHAR2(20); 
        raw_buffer_   VARCHAR2(32000);
    BEGIN
        len_ := DBMS_LOB.GETLENGTH( blob_ );
        IF blob_ IS NULL OR nvl(len_,0) = 0 THEN
            RETURN NULL;
        END IF;
        IF len_ <= 32760 AND start_pos_ = 1 AND stop_pos_ IS NULL THEN
            RETURN utl_encode.base64_decode( blob_ );
        END IF;
        
        
        DBMS_lob.createtemporary( tmp_blob_, true );
        start_ := start_pos_;
        IF stop_pos_ IS NOT NULL THEN
            len_ := stop_pos_;
        END IF;
        pos_ := 1;
        prev_buffer_ := '';
        WHILE start_ <= len_ LOOP
            amount_ := least( 16500, len_ - start_ + 1 );  -- 16500 must be divided by 66
            raw_buffer_ := DBMS_LOB.SUBSTR( blob_, amount => amount_, offset => start_ );
            start_ := start_ + amount_;
            IF (prev_buffer_ IS NOT NULL) OR DBMS_LOB.INSTR( raw_buffer_,  utl_raw.cast_to_raw(chr(10)) ) > 0 THEN
                buffer_ := prev_buffer_ || replace( replace( utl_raw.cast_to_varchar2( raw_buffer_ ), chr(13), ''), chr(10), '');
                IF (start_ <= len_) AND (mod( length(buffer_), 4 ) != 0) THEN
                    buffer_len_ := length(buffer_) - mod( length(buffer_), 4 );
                    prev_buffer_ := substr( buffer_, buffer_len_+1 );
                    buffer_ := substr( buffer_, 1, buffer_len_ );
                ELSE
                    prev_buffer_ := NULL;
                END IF;
                raw_buffer_ := utl_encode.base64_decode( UTL_RAW.CAST_TO_RAW( buffer_ ) );
            ELSE
                raw_buffer_ := utl_encode.base64_decode( raw_buffer_ );
            END IF;            
            buffer_len_ := utl_raw.length( raw_buffer_ );
            DBMS_lob.write( tmp_blob_, buffer_len_, pos_, raw_buffer_ );
            pos_ := pos_ + buffer_len_;
        END LOOP;
        IF prev_buffer_ IS NOT NULL THEN
            buffer_ := prev_buffer_;
            raw_buffer_ := UTL_RAW.CAST_TO_RAW( buffer_ );            
            buffer_len_ := utl_raw.length( raw_buffer_ );
            DBMS_lob.write( tmp_blob_, buffer_len_, pos_, raw_buffer_ );
            --pos_ := pos_ + amount_;
        END IF;
        ret_ := tmp_blob_;
        DBMS_LOB.freetemporary(tmp_blob_);
        RETURN ret_;
    END;
    
    
    
          
    PROCEDURE Wcf_Web_Service( request_before_ IN VARCHAR2, request_ IN OUT NOCOPY BLOB, request_after_ IN VARCHAR2,
                               response_ IN OUT NOCOPY BLOB ) IS
       http_req_        UTL_HTTP.req;
       http_resp_       UTL_HTTP.resp;
       tmp_response_    BLOB;
  
       buffer_          RAW(32767); 
       buffer_tmp_      RAW(32767); 
       len_             PLS_INTEGER;
       pos_             PLS_INTEGER;
       row_nr_          PLS_INTEGER;
       amount_          PLS_INTEGER;
    BEGIN
       http_req_ := UTL_HTTP.begin_request(service_address_, 'POST', 'HTTP/1.1' );
       BEGIN
           --UTL_HTTP.set_persistent_conn_support(http_req_, TRUE);
           --UTL_HTTP.set_header (http_req_, 'Authorization', 'Basic ' || authorization_);
           UTL_HTTP.set_header (http_req_, 'Content-Type', 'text/xml'); 
           UTL_HTTP.set_header (http_req_, 'SoapAction', 'http://www.bimodal-solutions.com/IService/ExecProc');
           --UTL_HTTP.set_header (http_req_, 'User-Agent', 'Apache-HttpClient/4.1.1 (java 1.5)');
           --UTL_HTTP.set_header (http_req_, 'Accept-Encoding', 'gzip,deflate');
           len_ := DBMS_lob.getlength(request_);
           UTL_HTTP.set_header (http_req_, 'Content-Length', 
                      nvl(length(request_before_),0)+ len_ + nvl(length(request_after_),0));

           IF request_before_ IS NOT NULL THEN
               UTL_HTTP.write_text (http_req_, request_before_);
           END IF;
           pos_ := 1;
           WHILE pos_ <= len_ LOOP
               amount_ := least( 32000, len_ - pos_ + 1);
               UTL_HTTP.write_raw (http_req_, DBMS_LOB.Substr(request_, amount_, pos_ ) );
               pos_ := pos_ + amount_;
           END LOOP;

           IF request_after_ IS NOT NULL THEN
               UTL_HTTP.write_text (http_req_, request_after_);
           END IF;

       EXCEPTION WHEN OTHERS THEN
           UTL_HTTP.end_request( http_req_ );
           RAISE;
       END;
       
       http_resp_ := UTL_HTTP.get_response (http_req_);
  

       row_nr_ := 0;
       BEGIN
          loop
              UTL_HTTP.read_raw( http_resp_, buffer_, 32760);
              
              IF row_nr_ = 1 THEN
                  DBMS_lob.createtemporary( tmp_response_, true );
                  DBMS_lob.append( tmp_response_, buffer_tmp_ ); 
              END IF;

              row_nr_ := row_nr_ + 1;
              IF row_nr_ > 1 THEN
                  DBMS_lob.append( tmp_response_, buffer_ ); 
              ELSE --row_nr_ = 1 THEN
                  buffer_tmp_ := buffer_;
              END IF;
          end loop;
       EXCEPTION 
       WHEN UTL_HTTP.END_OF_BODY THEN
          IF row_nr_ <= 1 THEN
                UTL_HTTP.end_response( http_resp_ );
                response_ := buffer_tmp_;
                RETURN;  --- !!!!  RETURN  !!!!  
          END IF;   
       WHEN OTHERS THEN
           UTL_HTTP.end_response( http_resp_ );
           IF row_nr_ > 1 THEN
               DBMS_LOB.freetemporary(tmp_response_);
           END IF;
           RAISE;
       END;
       UTL_HTTP.end_response( http_resp_ );
       response_ := tmp_response_;
       DBMS_LOB.freetemporary(tmp_response_);
    END;

    FUNCTION Exec( proc_name_ IN VARCHAR2, 
                   attr_      IN Attr_Obj DEFAULT NULL,
                   param1_    IN VARCHAR2 DEFAULT NULL,
                   param2_    IN VARCHAR2 DEFAULT NULL,
                   param3_    IN VARCHAR2 DEFAULT NULL,
                   param4_    IN VARCHAR2 DEFAULT NULL,
                   param5_    IN VARCHAR2 DEFAULT NULL ) RETURN Attr_Obj IS
        request_before_  VARCHAR2(4000);
        request_after_   VARCHAR2(4000);
        request_         BLOB;
        response_        BLOB;
        attr_tmp_        Attr_Obj;
        body_xml_        RAW(20);
    BEGIN
        IF fnd_Api.Log_Is_On() THEN
            fnd_Api.Time_Start( 'Wcf_Web_Service '||proc_name_ );
        END IF;
        attr_tmp_ := Attr_Obj();
        attr_tmp_.Copy_From( attr_ );
        request_ := Attr_To_Blob( attr_tmp_ );
        -- IMPORTANT: EnvId, PARAM1, PARAM2 ... ProcedureName ... - alphabetical order
        request_before_ := '<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns="http://www.bimodal-solutions.com/"><soapenv:Header><paramRequestHeader>'||
                           '<EnvId>'|| fnd_API.environment_id_ ||'</EnvId>'||
                           '<Param1>'|| param1_ ||'</Param1>'||
                           '<Param2>'|| param2_ ||'</Param2>'||
                           '<Param3>'|| param3_ ||'</Param3>'||
                           '<Param4>'|| param4_ ||'</Param4>'||
                           '<Param5>'|| param5_ ||'</Param5>'||
                           '<ProcedureName>'|| proc_name_ ||'</ProcedureName>'||
                           '<Token>'|| token_ ||'</Token>'||
                           '<UserId>'|| fnd_API.curr_user_id_ ||'</UserId>'||
                           '</paramRequestHeader></soapenv:Header><soapenv:Body><ParamRequest><bodyXml>';
        request_after_  := '</bodyXml></ParamRequest></soapenv:Body></soapenv:Envelope>';
        request_ := To_Base64( request_ );
        Wcf_Web_Service( request_before_, request_, request_after_, response_ );

        body_xml_ := utl_raw.cast_to_raw('<bodyXml>');
        response_ := From_Base64( response_, DBMS_LOB.INSTR( response_, body_xml_ ) + utl_raw.length(body_xml_), 
                                  DBMS_LOB.INSTR( response_,  utl_raw.cast_to_raw('</bodyXml>') ) -1 );

        IF fnd_Api.Log_Is_On() THEN
            fnd_Api.Time_Stop( 'Wcf_Web_Service '||proc_name_ );
        END IF;
        RETURN Blob_To_Attr( response_ );
    END;


    
        
end Wcf_Api;
/
